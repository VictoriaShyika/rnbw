"use strict";(self.webpackChunkrainbow=self.webpackChunkrainbow||[]).push([[6016],{86016:function(e,i,t){t.r(i),t.d(i,{FileHandle:function(){return d},FolderHandle:function(){return y},setBlobImpl:function(){return l},setFileImpl:function(){return o}});var s=t(8716);let n=globalThis.File,r=globalThis.Blob;const o=e=>{n=e},l=e=>{r=e},{INVALID:h,GONE:a,MISMATCH:c,MOD_ERR:f,SYNTAX:w,DISALLOWED:p}=s.errors;class u{constructor(e,i){this.fileHandle=e,this.file=i?e.file:new n([],e.file.name,e.file),this.size=i?e.file.size:0,this.position=0}async write(e){if(!this.fileHandle.file)throw new DOMException(...a);let i=this.file;if((0,s.isChunkObject)(e))if("write"===e.type){if("number"==typeof e.position&&e.position>=0&&(this.position=e.position,this.size<e.position&&(this.file=new n([this.file,new ArrayBuffer(e.position-this.size)],this.file.name,this.file))),!("data"in e))throw new DOMException(...w("write requires a data argument"));e=e.data}else{if("seek"===e.type){if(Number.isInteger(e.position)&&e.position>=0){if(this.size<e.position)throw new DOMException(...h);return void(this.position=e.position)}throw new DOMException(...w("seek requires a position argument"))}if("truncate"===e.type){if(Number.isInteger(e.size)&&e.size>=0)return i=e.size<this.size?new n([i.slice(0,e.size)],i.name,i):new n([i,new Uint8Array(e.size-this.size)],i.name,i),this.size=i.size,this.position>i.size&&(this.position=i.size),void(this.file=i);throw new DOMException(...w("truncate requires a size argument"))}}e=new r([e]);let t=this.file;const o=t.slice(0,this.position),l=t.slice(this.position+e.size);let c=this.position-o.size;c<0&&(c=0),t=new n([o,new Uint8Array(c),e,l],t.name),this.size=t.size,this.position+=e.size,this.file=t}async close(){if(!this.fileHandle.file)throw new DOMException(...a);this.fileHandle.file=this.file,this.file=this.position=this.size=null,this.fileHandle.onclose&&this.fileHandle.onclose(this.fileHandle)}}class d{constructor(e="",i=new n([],e),t=!0){this.kind="file",this.deleted=!1,this.file=i,this.name=e,this.writable=t}async getFile(){if(this.deleted||null===this.file)throw new DOMException(...a);return this.file}async createWritable(e){if(!this.writable)throw new DOMException(...p);if(this.deleted)throw new DOMException(...a);return new u(this,!!(null==e?void 0:e.keepExistingData))}async isSameEntry(e){return this===e}destroy(){this.deleted=!0,this.file=null}}class y{constructor(e,i=!0){this.kind="directory",this.deleted=!1,this._entries={},this.name=e,this.writable=i}async*entries(){if(this.deleted)throw new DOMException(...a);yield*Object.entries(this._entries)}async isSameEntry(e){return this===e}async getDirectoryHandle(e,i={}){if(this.deleted)throw new DOMException(...a);const t=this._entries[e];if(t){if(t instanceof d)throw new DOMException(...c);return t}if(i.create)return this._entries[e]=new y(e);throw new DOMException(...a)}async getFileHandle(e,i={}){const t=this._entries[e];if(t){if(t instanceof d)return t;throw new DOMException(...c)}if(i.create)return this._entries[e]=new d(e);throw new DOMException(...a)}async removeEntry(e,i={}){const t=this._entries[e];if(!t)throw new DOMException(...a);t.destroy(i.recursive),delete this._entries[e]}destroy(e){for(let i of Object.values(this._entries)){if(!e)throw new DOMException(...f);i.destroy(e)}this._entries={},this.deleted=!0}}const E=new y("");i.default=()=>E}}]);